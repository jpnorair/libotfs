/* Copyright 2017 JP Norair
  *
  * Licensed under the OpenTag License, Version 1.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  * http://www.indigresso.com/wiki/doku.php?id=opentag:license_1_0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  */
/**
  * @file       /app/csip_c2000/fs_defaults.h
  * @author     JP Norair
  * @version    R102
  * @date       9 May 2017
  * @brief      Startup Data for default filesystem
  * 
  ******************************************************************************
  */

#ifndef __DEFAULT_FS_STARTUP_H
#define __DEFAULT_FS_STARTUP_H

#include <otstd.h>
#include <board.h>

// Local App FS Configuration
#include "fs_config.h"



/// Constant "_ERS" is the value of an erased byte in nonvolatile memory.
/// Usually it is FF or 00, depending on the way the Flash memory is designed.
#ifndef _ERS
#   define _ERS     0xFF
#endif
#ifndef _ERS16
#   define _ERS16   0xFFFF
#endif

/// The OpenTag startup routine will place IDs generated by programmatic means
/// in this empty space.
#define __VID   _ERS16
#define __UID   _ERS16, _ERS16, _ERS16, _ERS16



/** Default File data allocations
  * ============================================================================
  */

// C2000 is little endian with 16 bit byte.
// We put normal 8 bit bytes into 16 bit byte in network endian order
// MSB = +1
// LSB = 0
#define JOIN_2BYTES(B0, B1) (ot_u16)((((ot_u16)(B1))<<8)|((ot_u16)(B0)))

#define SPLIT_SHORT(VAL)    (((ot_u16)(VAL) >> 8) | ((ot_u16)(VAL) << 8))
#define SPLIT_SHORT_LE(VAL) (VAL)

#define SPLIT_LONG(VAL)     (ot_u16)((((ot_u32)(VAL)) >> 16) & 0xFFFF), (ot_u16)(((ot_u32)(VAL)) & 0xFFFF)
#define SPLIT_LONG_LE(VAL)  (ot_u16)(((ot_u32)(VAL)) & 0xFFFF), (ot_u16)((((ot_u32)(VAL)) >> 16) & 0xFFFF)

#if (OT_FEATURE(VLACTIONS) == ENABLED)
#   define FILE_ACTIONCODE(COND,ID) JOIN_2BYTES(COND, ID)
#else
#   define FILE_ACTIONCODE(COND,ID), 
#endif
#if (OT_FEATURE(VLMODTIME) == ENABLED)
#   define FILE_MODTIME(EPOCH_S) SPLIT_LONG_LE(EPOCH_S)
#else
#   define FILE_MODTIME(EPOCH_S), 
#endif
#if (OT_FEATURE(VLACCTIME) == ENABLED)
#   define FILE_ACCTIME(EPOCH_S) SPLIT_LONG_LE(EPOCH_S)
#else
#   define FILE_ACCTIME(EPOCH_S), 
#endif

#ifndef OT_ACTIVE_SETTINGS
#   define OT_ACTIVE_SETTINGS 0
#endif
#ifndef OT_SUPPORTED_SETTINGS
#   define OT_SUPPORTED_SETTINGS 0
#endif





/// These overhead are the Veelite vl_header_t files. They are hard coded,
/// and they must be in the endian of the platform. (Little endian here)

#if defined(__NO_SECTIONS__)
const ot_u16 overhead_files[] = {
#elif (CC_SUPPORT == GCC)
const ot_u16 overhead_files[] __attribute__ ((section(".vl_ov"))) = {
#elif (CC_SUPPORT == TI_C)
#pragma DATA_SECTION(overhead_files, ".vl_ov")
const ot_u16 overhead_files[] = {
#endif
    /* Filesystem Header: Same size as two file headers (24 bytes) */
    OVERHEAD_TOTAL_BYTES,
#   if (OT_FEATURE(VLACTIONS) == ENABLED)
    SPLIT_SHORT_LE(0),
    SPLIT_SHORT_LE(0),
#   endif
    GFB_TOTAL_BYTES,
    GFB_STOCK_BYTES,
    GFB_NUM_STOCK_FILES,
    ISS_TOTAL_BYTES,
    ISS_STOCK_BYTES,
    ISS_NUM_STOCK_FILES,
    ISF_TOTAL_BYTES,
    ISF_STOCK_BYTES,
    ISF_NUM_STOCK_FILES,
#   if (OT_FEATURE(VLMODTIME) == ENABLED)
    SPLIT_LONG_LE(0),
    SPLIT_LONG_LE(0),
#   endif
#   if (OT_FEATURE(VLACCTIME) == ENABLED)
    SPLIT_LONG_LE(0),
    SPLIT_LONG_LE(0),
#   endif

    /* GFB Files */
    JOIN_2BYTES(0x00, 0x00), JOIN_2BYTES(0x00, 0x01),                 /* GFB Element 0 */
    JOIN_2BYTES(0x00, GFB_MOD_standard),
    JOIN_2BYTES(0x00, 0x14), JOIN_2BYTES(0xFF, 0xFF),
    FILE_ACTIONCODE(0,0),
#	if (OT_FEATURE(VLMODTIME) == ENABLED)
    FILE_MODTIME(0),
#	endif
#   if (OT_FEATURE(VLACCTIME) == ENABLED)
    FILE_ACCTIME(0),
#   endif

    JOIN_2BYTES(0x00, 0x00), JOIN_2BYTES(0x00, 0x01),                 /* GFB Element 1 */
    JOIN_2BYTES(0x01, GFB_MOD_standard),
    JOIN_2BYTES(0x00, 0x14), JOIN_2BYTES(0xFF, 0xFF),
    FILE_ACTIONCODE(0,0),
#   if (OT_FEATURE(VLMODTIME) == ENABLED)
    FILE_MODTIME(0),
#   endif
#   if (OT_FEATURE(VLACCTIME) == ENABLED)
    FILE_ACCTIME(0),
#   endif
    
    /* Mode 2 ISFs, written as little endian */
    JOIN_2BYTES(ISF_LEN(network_settings), 0x00),                       /* Length, little endian */
    ISF_ALLOC(network_settings),                        /* Alloc, little endian */
    JOIN_2BYTES(ISF_ID(network_settings), ISF_MOD(network_settings)),   /* ID , Perms*/
    ISF_BASE(network_settings),
    ISF_MIRROR(network_settings),
    FILE_ACTIONCODE(0,0),
#	if (OT_FEATURE(VLMODTIME) == ENABLED)
    FILE_MODTIME(0),
#	endif
#   if (OT_FEATURE(VLACCTIME) == ENABLED)
    FILE_ACCTIME(0),
#   endif

    JOIN_2BYTES(ISF_LEN(device_features), 0x00),
    (ISF_ALLOC(device_features)),
    JOIN_2BYTES(ISF_ID(device_features), ISF_MOD(device_features)),
    (ISF_BASE(device_features)),
    (ISF_MIRROR(device_features)),
    FILE_ACTIONCODE(0,0),
#	if (OT_FEATURE(VLMODTIME) == ENABLED)
    FILE_MODTIME(0),
#	endif
#   if (OT_FEATURE(VLACCTIME) == ENABLED)
    FILE_ACCTIME(0),
#   endif

    JOIN_2BYTES(ISF_LEN(channel_configuration), 0x00),
    (ISF_ALLOC(channel_configuration)),
    JOIN_2BYTES(ISF_ID(channel_configuration), ISF_MOD(channel_configuration)),
    (ISF_BASE(channel_configuration)),
    (ISF_MIRROR(channel_configuration)),
    FILE_ACTIONCODE(0,0),
#	if (OT_FEATURE(VLMODTIME) == ENABLED)
    FILE_MODTIME(0),
#	endif
#   if (OT_FEATURE(VLACCTIME) == ENABLED)
    FILE_ACCTIME(0),
#   endif

    JOIN_2BYTES(ISF_LEN(real_time_scheduler), 0x00),
    (ISF_ALLOC(real_time_scheduler)),
    JOIN_2BYTES(ISF_ID(real_time_scheduler), ISF_MOD(real_time_scheduler)),
    (ISF_BASE(real_time_scheduler)),
    (ISF_MIRROR(real_time_scheduler)),
    FILE_ACTIONCODE(0,0),
#	if (OT_FEATURE(VLMODTIME) == ENABLED)
    FILE_MODTIME(0),
#	endif
#   if (OT_FEATURE(VLACCTIME) == ENABLED)
    FILE_ACCTIME(0),
#   endif

    JOIN_2BYTES(ISF_LEN(hold_scan_sequence), 0x00),
    (ISF_ALLOC(hold_scan_sequence)),
    JOIN_2BYTES(ISF_ID(hold_scan_sequence), ISF_MOD(hold_scan_sequence)),
    (ISF_BASE(hold_scan_sequence)),
    (ISF_MIRROR(hold_scan_sequence)),
    FILE_ACTIONCODE(0,0),
#	if (OT_FEATURE(VLMODTIME) == ENABLED)
    FILE_MODTIME(0),
#	endif
#   if (OT_FEATURE(VLACCTIME) == ENABLED)
    FILE_ACCTIME(0),
#   endif

    JOIN_2BYTES(ISF_LEN(sleep_scan_sequence), 0x00),
    (ISF_ALLOC(sleep_scan_sequence)),
    JOIN_2BYTES(ISF_ID(sleep_scan_sequence), ISF_MOD(sleep_scan_sequence)),
    (ISF_BASE(sleep_scan_sequence)),
    (ISF_MIRROR(sleep_scan_sequence)),
    FILE_ACTIONCODE(0,0),
#	if (OT_FEATURE(VLMODTIME) == ENABLED)
    FILE_MODTIME(0),
#	endif
#   if (OT_FEATURE(VLACCTIME) == ENABLED)
    FILE_ACCTIME(0),
#   endif

    JOIN_2BYTES(ISF_LEN(beacon_transmit_sequence), 0x00),
    (ISF_ALLOC(beacon_transmit_sequence)),
    JOIN_2BYTES(ISF_ID(beacon_transmit_sequence), ISF_MOD(beacon_transmit_sequence)),
    (ISF_BASE(beacon_transmit_sequence)),
    (ISF_MIRROR(beacon_transmit_sequence)),
    FILE_ACTIONCODE(0,0),
#	if (OT_FEATURE(VLMODTIME) == ENABLED)
    FILE_MODTIME(0),
#	endif
#   if (OT_FEATURE(VLACCTIME) == ENABLED)
    FILE_ACCTIME(0),
#   endif

    JOIN_2BYTES(ISF_LEN(isf_list), 0x00),
    (ISF_ALLOC(isf_list)),
    JOIN_2BYTES(ISF_ID(isf_list),ISF_MOD(isf_list)),
    (ISF_BASE(isf_list)),
    (ISF_MIRROR(isf_list)),
    FILE_ACTIONCODE(0,0),
#	if (OT_FEATURE(VLMODTIME) == ENABLED)
    FILE_MODTIME(0),
#	endif
#   if (OT_FEATURE(VLACCTIME) == ENABLED)
    FILE_ACCTIME(0),
#   endif

    JOIN_2BYTES(ISF_LEN(iss_list), 0x00),
    (ISF_ALLOC(iss_list)),
    JOIN_2BYTES(ISF_ID(iss_list), ISF_MOD(iss_list)),
    (ISF_BASE(iss_list)),
    (ISF_MIRROR(iss_list)),
    FILE_ACTIONCODE(0,0),
#	if (OT_FEATURE(VLMODTIME) == ENABLED)
    FILE_MODTIME(0),
#	endif
#   if (OT_FEATURE(VLACCTIME) == ENABLED)
    FILE_ACCTIME(0),
#   endif

    JOIN_2BYTES(ISF_LEN(gfb_file_list), 0x00),
    (ISF_ALLOC(gfb_file_list)),
    JOIN_2BYTES(ISF_ID(gfb_file_list), ISF_MOD(gfb_file_list)),
    (ISF_BASE(gfb_file_list)),
    (ISF_MIRROR(gfb_file_list)),
    FILE_ACTIONCODE(0,0),
#	if (OT_FEATURE(VLMODTIME) == ENABLED)
    FILE_MODTIME(0),
#	endif
#   if (OT_FEATURE(VLACCTIME) == ENABLED)
    FILE_ACCTIME(0),
#   endif

    JOIN_2BYTES(ISF_LEN(location_data_list), 0x00),
    (ISF_ALLOC(location_data_list)),
    JOIN_2BYTES(ISF_ID(location_data_list), ISF_MOD(location_data_list)),
    (ISF_BASE(location_data_list)),
    (ISF_MIRROR(location_data_list)),
    FILE_ACTIONCODE(0,0),
#	if (OT_FEATURE(VLMODTIME) == ENABLED)
    FILE_MODTIME(0),
#	endif
#   if (OT_FEATURE(VLACCTIME) == ENABLED)
    FILE_ACCTIME(0),
#   endif

    JOIN_2BYTES(ISF_LEN(ipv6_addresses), 0x00),
    (ISF_ALLOC(ipv6_addresses)),
    JOIN_2BYTES(ISF_ID(ipv6_addresses), ISF_MOD(ipv6_addresses)),
    (ISF_BASE(ipv6_addresses)),
    (ISF_MIRROR(ipv6_addresses)),
    FILE_ACTIONCODE(0,0),
#	if (OT_FEATURE(VLMODTIME) == ENABLED)
    FILE_MODTIME(0),
#	endif
#   if (OT_FEATURE(VLACCTIME) == ENABLED)
    FILE_ACCTIME(0),
#   endif

    JOIN_2BYTES(ISF_LEN(sensor_list), 0x00),
    (ISF_ALLOC(sensor_list)),
    JOIN_2BYTES(ISF_ID(sensor_list), ISF_MOD(sensor_list)),
    (ISF_BASE(sensor_list)),
    (ISF_MIRROR(sensor_list)),
    FILE_ACTIONCODE(0,0),
#	if (OT_FEATURE(VLMODTIME) == ENABLED)
    FILE_MODTIME(0),
#	endif
#   if (OT_FEATURE(VLACCTIME) == ENABLED)
    FILE_ACCTIME(0),
#   endif

    JOIN_2BYTES(ISF_LEN(sensor_alarms), 0x00),
    (ISF_ALLOC(sensor_alarms)),
    JOIN_2BYTES(ISF_ID(sensor_alarms), ISF_MOD(sensor_alarms)),
    (ISF_BASE(sensor_alarms)),
    (ISF_MIRROR(sensor_alarms)),
    FILE_ACTIONCODE(0,0),
#	if (OT_FEATURE(VLMODTIME) == ENABLED)
    FILE_MODTIME(0),
#	endif
#   if (OT_FEATURE(VLACCTIME) == ENABLED)
    FILE_ACCTIME(0),
#   endif

    JOIN_2BYTES(ISF_LEN(root_authentication_key), 0x00),
    (ISF_ALLOC(root_authentication_key)),
    JOIN_2BYTES(ISF_ID(root_authentication_key), ISF_MOD(root_authentication_key)),
    (ISF_BASE(root_authentication_key)),
    (ISF_MIRROR(root_authentication_key)),
    FILE_ACTIONCODE(0,0),
#	if (OT_FEATURE(VLMODTIME) == ENABLED)
    FILE_MODTIME(0),
#	endif
#   if (OT_FEATURE(VLACCTIME) == ENABLED)
    FILE_ACCTIME(0),
#   endif

    JOIN_2BYTES(ISF_LEN(user_authentication_key), 0x00),
    (ISF_ALLOC(user_authentication_key)),
    JOIN_2BYTES(ISF_ID(user_authentication_key), ISF_MOD(user_authentication_key)),
    (ISF_BASE(user_authentication_key)),
    (ISF_MIRROR(user_authentication_key)),
    FILE_ACTIONCODE(0,0),
#	if (OT_FEATURE(VLMODTIME) == ENABLED)
    FILE_MODTIME(0),
#	endif
#   if (OT_FEATURE(VLACCTIME) == ENABLED)
    FILE_ACCTIME(0),
#   endif

    JOIN_2BYTES(ISF_LEN(pwrdata_inv), 0x00),
    (ISF_ALLOC(pwrdata_inv)),
    JOIN_2BYTES(ISF_ID(pwrdata_inv), ISF_MOD(pwrdata_inv)),
    (ISF_BASE(pwrdata_inv)),
    (ISF_MIRROR(pwrdata_inv)),
    FILE_ACTIONCODE(0,0),
#	if (OT_FEATURE(VLMODTIME) == ENABLED)
    FILE_MODTIME(0),
#	endif
#   if (OT_FEATURE(VLACCTIME) == ENABLED)
    FILE_ACCTIME(0),
#   endif

    JOIN_2BYTES(ISF_LEN(pwrdata_mppt), 0x00),
    (ISF_ALLOC(pwrdata_mppt)),
    JOIN_2BYTES(ISF_ID(pwrdata_mppt), ISF_MOD(pwrdata_mppt)),
    (ISF_BASE(pwrdata_mppt)),
    (ISF_MIRROR(pwrdata_mppt)),
    FILE_ACTIONCODE(0,0),
#	if (OT_FEATURE(VLMODTIME) == ENABLED)
    FILE_MODTIME(0),
#	endif
#   if (OT_FEATURE(VLACCTIME) == ENABLED)
    FILE_ACCTIME(0),
#   endif

    JOIN_2BYTES(ISF_LEN(csip_nameplate_inv), 0x00),
    (ISF_ALLOC(csip_nameplate_inv)),
    JOIN_2BYTES(ISF_ID(csip_nameplate_inv), ISF_MOD(csip_nameplate_inv)),
    (ISF_BASE(csip_nameplate_inv)),
    (ISF_MIRROR(csip_nameplate_inv)),
    FILE_ACTIONCODE(0,0),
#	if (OT_FEATURE(VLMODTIME) == ENABLED)
    FILE_MODTIME(0),
#	endif
#   if (OT_FEATURE(VLACCTIME) == ENABLED)
    FILE_ACCTIME(0),
#   endif

    JOIN_2BYTES(ISF_LEN(csip_nameplate_mppt), 0x00),
    (ISF_ALLOC(csip_nameplate_mppt)),
    JOIN_2BYTES(ISF_ID(csip_nameplate_mppt), ISF_MOD(csip_nameplate_mppt)),
    (ISF_BASE(csip_nameplate_mppt)),
    (ISF_MIRROR(csip_nameplate_mppt)),
    FILE_ACTIONCODE(0,0),
#	if (OT_FEATURE(VLMODTIME) == ENABLED)
    FILE_MODTIME(0),
#	endif
#   if (OT_FEATURE(VLACCTIME) == ENABLED)
    FILE_ACCTIME(0),
#   endif

    JOIN_2BYTES(ISF_LEN(csip_cfg), 0x00),
    (ISF_ALLOC(csip_cfg)),
    JOIN_2BYTES(ISF_ID(csip_cfg), ISF_MOD(csip_cfg)),
    (ISF_BASE(csip_cfg)),
    (ISF_MIRROR(csip_cfg)),
    FILE_ACTIONCODE(0,0),
#	if (OT_FEATURE(VLMODTIME) == ENABLED)
    FILE_MODTIME(0),
#	endif
#   if (OT_FEATURE(VLACCTIME) == ENABLED)
    FILE_ACCTIME(0),
#   endif

    JOIN_2BYTES(ISF_LEN(csip_setarray), 0x00),
    (ISF_ALLOC(csip_setarray)),
    JOIN_2BYTES(ISF_ID(csip_setarray), ISF_MOD(csip_setarray)),
    (ISF_BASE(csip_setarray)),
    (ISF_MIRROR(csip_setarray)),
    FILE_ACTIONCODE(0,0),
#	if (OT_FEATURE(VLMODTIME) == ENABLED)
    FILE_MODTIME(0),
#	endif
#   if (OT_FEATURE(VLACCTIME) == ENABLED)
    FILE_ACCTIME(0),
#   endif

    JOIN_2BYTES(ISF_LEN(csip_issuecmd), 0x00),
    (ISF_ALLOC(csip_issuecmd)),
    JOIN_2BYTES(ISF_ID(csip_issuecmd), ISF_MOD(csip_issuecmd)),
    (ISF_BASE(csip_issuecmd)),
    (ISF_MIRROR(csip_issuecmd)),
    FILE_ACTIONCODE(0,0),
#	if (OT_FEATURE(VLMODTIME) == ENABLED)
    FILE_MODTIME(0),
#	endif
#   if (OT_FEATURE(VLACCTIME) == ENABLED)
    FILE_ACCTIME(0),
#   endif

    JOIN_2BYTES(ISF_LEN(csip_operations), 0x00),
    (ISF_ALLOC(csip_operations)),
    JOIN_2BYTES(ISF_ID(csip_operations), ISF_MOD(csip_operations)),
    (ISF_BASE(csip_operations)),
    (ISF_MIRROR(csip_operations)),
    FILE_ACTIONCODE(0,0),
#	if (OT_FEATURE(VLMODTIME) == ENABLED)
    FILE_MODTIME(0),
#	endif
#   if (OT_FEATURE(VLACCTIME) == ENABLED)
    FILE_ACCTIME(0),
#   endif

    JOIN_2BYTES(ISF_LEN(csip_issuecontrol), 0x00),
    (ISF_ALLOC(csip_issuecontrol)),
    JOIN_2BYTES(ISF_ID(csip_issuecontrol), ISF_MOD(csip_issuecontrol)),
    (ISF_BASE(csip_issuecontrol)),
    (ISF_MIRROR(csip_issuecontrol)),
    FILE_ACTIONCODE(0,0),
#   if (OT_FEATURE(VLMODTIME) == ENABLED)
    FILE_MODTIME(0),
#   endif
#   if (OT_FEATURE(VLACCTIME) == ENABLED)
    FILE_ACCTIME(0),
#   endif

    JOIN_2BYTES(ISF_LEN(application_extension), 0x00),
    (ISF_ALLOC(application_extension)),
    JOIN_2BYTES(ISF_ID(application_extension), ISF_MOD(application_extension)),
    (ISF_BASE(application_extension)),
    (ISF_MIRROR(application_extension)),
    FILE_ACTIONCODE(0,0),
#	if (OT_FEATURE(VLMODTIME) == ENABLED)
    FILE_MODTIME(0),
#	endif
#   if (OT_FEATURE(VLACCTIME) == ENABLED)
    FILE_ACCTIME(0),
#   endif
};




#if (GFB_TOTAL_BYTES > 0)
#   if defined(__NO_SECTIONS__)
    const ot_u16 gfb_stock_files[] = { _ERS16 };

#   elif (CC_SUPPORT == GCC)
    const ot_u16 gfb_stock_files[GFB_TOTAL_BYTES/2] __attribute__((section(".vl_gfb"))) = { _ERS16 };
    
#   elif (CC_SUPPORT == TI_C)
#   pragma DATA_SECTION(gfb_stock_files, ".vl_gfb")
    const ot_u16 gfb_stock_files[GFB_TOTAL_BYTES/2] = { _ERS16 };
#   endif
#endif



#if (ISS_TOTAL_BYTES > 0)
#   if defined(__NO_SECTIONS__)
    const ot_u16 iss_stock_files[] = { _ERS };

#   elif (CC_SUPPORT == GCC)
    const ot_u16 iss_stock_files[ISS_TOTAL_BYTES/2] __attribute__((section(".vl_iss"))) = { _ERS };
    
#   elif (CC_SUPPORT == TI_C)
#   pragma DATA_SECTION(gfb_stock_files, ".vl_iss")
    const ot_u16 iss_stock_files[ISS_TOTAL_BYTES/2] = { _ERS };
#   endif
#else

    const ot_u16 iss_stock_files[] = { 0 };
#endif


/// Firmware & Version information for ISF1 (Device Features)
/// This will look something like "OTv1  xyyyyyyy" where x is a letter and
/// yyyyyyy is a Base64 string containing a 16 bit build-id and a 32 bit mask
/// indicating the features compiled-into the build.
#include <otsys/version.h>

#define BV0     (ot_u8)(OT_VERSION_MAJOR + 48)
#define BT0     (ot_u8)(OT_BUILDTYPE)
#define BC0     OT_BUILDCODE0
#define BC1     OT_BUILDCODE1
#define BC2     OT_BUILDCODE2
#define BC3     OT_BUILDCODE3
#define BC4     OT_BUILDCODE4
#define BC5     OT_BUILDCODE5
#define BC6     OT_BUILDCODE6
#define BC7     OT_BUILDCODE7

/// This array contains the stock ISF data.  ISF data must be big endian!
#if defined(__NO_SECTIONS__)
const ot_u16 isf_stock_files[] = {
#elif (CC_SUPPORT == GCC)
const ot_u16 isf_stock_files[] __attribute__((section(".vl_isf"))) = {
#elif (CC_SUPPORT == TI_C)
#pragma DATA_SECTION(isf_stock_files, ".vl_isf")
const ot_u16 isf_stock_files[] = {
#endif
    /* network settings: id=0x00, len=10, alloc=10 */
    __VID,                                              /* VID */
    JOIN_2BYTES(0x01, 0x00),                            /* Device Subnet, Beacon Subnet */
    PLATFORM_ENDIAN16_C(OT_ACTIVE_SETTINGS),                    /* Active Setting */
    JOIN_2BYTES(0x00, 1),                               /* Default Device Flags, Beacon Attempts */
    PLATFORM_ENDIAN16_C(0),                                     /* Hold Scan Sequence Cycles */

    _ERS16, //Alignment Padding

    /* device features: id=0x01, len=48, alloc=48 */
    __UID,                                              /* UID: 8 bytes*/
    PLATFORM_ENDIAN16_C(OT_SUPPORTED_SETTINGS),                 /* Supported Setting */
    JOIN_2BYTES(255, 1),                                /* Max Frame Length, Max Frames per Packet */
    PLATFORM_ENDIAN16_C(1),                                     /* DLLS Methods */
    PLATFORM_ENDIAN16_C(0),                                     /* NLS Methods */
    PLATFORM_ENDIAN16_C(ISF_TOTAL_BYTES),                       /* ISFB Total Memory */
    PLATFORM_ENDIAN16_C(ISF_TOTAL_BYTES-ISF_HEAP_BYTES),        /* ISFB Available Memory */
    PLATFORM_ENDIAN16_C(0),                                     /* ISFSB Total Memory */
    PLATFORM_ENDIAN16_C(0),                                     /* ISFSB Available Memory */
    PLATFORM_ENDIAN16_C(GFB_TOTAL_BYTES),                       /* GFB Total Memory */
    PLATFORM_ENDIAN16_C(GFB_TOTAL_BYTES-GFB_HEAP_BYTES),        /* GFB Available Memory */
    PLATFORM_ENDIAN16_C(GFB_BLOCK_BYTES),                       /* GFB Block Size */
    JOIN_2BYTES(0, 0),                                  /* RFU, Session Stack Depth */
    JOIN_2BYTES('O','T'), JOIN_2BYTES('v',BV0),         /* Firmware & Version as C-string */
    JOIN_2BYTES(' ',' '),
    JOIN_2BYTES(BT0,BC0), 
    JOIN_2BYTES(BC1,BC2),
    JOIN_2BYTES(BC3,BC4),
    JOIN_2BYTES(BC5,BC6),
    JOIN_2BYTES(BC7, 0),             

    /* channel configuration: id=0x02, len=0, alloc=0 */

    /* real time scheduler: id=0x03, len=12, alloc=12 */
    SPLIT_LONG_LE(0),   // Time: Epoch Seconds since 01/01/1970
    SPLIT_LONG_LE(0),   // Time: Fractional Seconds
    SPLIT_LONG_LE(0),   // ModType

    /* hold scan periods: id=0x04, len=0, alloc=0 */
    /* Period data format in Section X.9.4.5 of Mode 2 spec */

    /* sleep scan periods: id=0x05, len=0, alloc=0 */
    /* Period data format in Section X.9.4.5 of Mode 2 spec */

    /* beacon transmit periods: id=0x06, len=0, alloc=0 */
    /* Period data format in Section X.9.4.7 of Mode 2 spec */ //0x0240

    /* User ISF List: id=0x07, len=8, alloc=24 */
    /* List of Protocols supported (Tentative)*/
    JOIN_2BYTES(0xFF, _ERS), _ERS16, _ERS16, _ERS16,     
    _ERS16, _ERS16, _ERS16, _ERS16, 
    _ERS16, _ERS16, _ERS16, _ERS16,

    /* ISFS list: id=0x08, len=0, alloc=0 */

    /* GFB File List: id=0x09, len=1, alloc=8 */
    JOIN_2BYTES(0x01, _ERS), _ERS16, _ERS16, _ERS16,

    /* Location Data List: id=0x0A, len=0, alloc=0 */

    /* IPv6 Addresses: id=0x0B, len=0, alloc=48 */
    _ERS16, _ERS16, _ERS16, _ERS16,
    _ERS16, _ERS16, _ERS16, _ERS16,
    _ERS16, _ERS16, _ERS16, _ERS16,
    _ERS16, _ERS16, _ERS16, _ERS16,
    _ERS16, _ERS16, _ERS16, _ERS16,
    _ERS16, _ERS16, _ERS16, _ERS16,

    /* Sensor List: id=0x0C, len=0, alloc=0 */

    /* Sensor Alarms: id=0x0D, len=0, alloc=0 */

    /* root auth key:       id=0x0E, len=22, alloc=22 */
    _ERS16, SPLIT_LONG_LE(172800),
    JOIN_2BYTES(0x00,0x11), JOIN_2BYTES(0x22,0x33),
    JOIN_2BYTES(0x44,0x55), JOIN_2BYTES(0x66,0x77),
    JOIN_2BYTES(0x88,0x99), JOIN_2BYTES(0xAA,0xBB),
    JOIN_2BYTES(0xCC,0xDD), JOIN_2BYTES(0xEE,0xFF),
    
    _ERS16, //Alignment Padding
    
    /* Admin auth key:      id=0x0F, len=22, alloc=22 */
    _ERS16, SPLIT_LONG_LE(172800),
    JOIN_2BYTES(0x00,0x01), JOIN_2BYTES(0x02,0x03),
    JOIN_2BYTES(0x04,0x05), JOIN_2BYTES(0x06,0x07),
    JOIN_2BYTES(0x08,0x09), JOIN_2BYTES(0x0A,0x0B),
    JOIN_2BYTES(0x0C,0x0D), JOIN_2BYTES(0x0E,0x0F),
    
    _ERS16, //Alignment Padding

    /* Power Data for Inverter: id=0x10, len=88, alloc=88 */
    (1),   // AC Current
    (2),   // AC Voltage
    (3),   // AC Frequency
    (4),   // AC Phase
    (5),   // Battery Capacity rating
    (6),   // Battery SOC
    (7),   // Battery SOH
    (8),   // Available energy of battery
    (9),   // Max Battery charge rate
    (10),   // Max Batter discharge rate
    (11),   // Battery voltage
    (12),   // Battery temperature
    (13),   // Active Power
    (14),   // Reactive Power
    (15),   // Power Factor
    (16),   // Inverter 1 Temperature
    (17),   // Inverter 2 Temperature
    (18),   // DC-DC Temperature
    (19),   // Grid Direction
    (20),   // Solpad Operating State
    (21),   // Time to Empty
    (22),   // Time to Full
    (23),
    (24),
    (25),
    _ERS16, //Alignment Padding
    
    /* Power Data for MPPT: id=0x11, len=80, alloc=80 */
    (1),   // PV1 Voltage
    (2),   // PV1 Current
    (3),   // PV1 Temperature
    (4),   // MPPT1 Voltage
    (5),   // MPPT1 Current
    (6),   // MPPT1 Temperature
    (7),   // Fill Factor 1
    (8),   // Efficiency 1
    (9),   // Maximum Available Power 1
    (10),   // PV2 Voltage
    (11),   // PV2 Current
    (12),   // PV2 Temperature
    (13),   // MPPT2 Voltage
    (14),   // MPPT2 Current
    (15),   // MPPT2 Temperature
    (16),   // Fill Factor 2
    (17),   // Efficiency 2
    (18),   // Maximum Available Power 2
    (19),   // MPPT Temperature
    (20),   // MPPT State

    /* CSIP Nameplate INV Ratings: id=0x12, len=36, alloc=36 */
    SPLIT_LONG_LE(1),   // Active Power rating
    SPLIT_LONG_LE(2),   // Apparent Power Rating
    SPLIT_LONG_LE(3),   // Reactive Power Rating
    SPLIT_LONG_LE(4),   // Maximum Battery Charge Rate
    SPLIT_LONG_LE(5),   // Maximum Battery Discharge Rate
    SPLIT_LONG_LE(6),   // Battery Present Indicator
    SPLIT_LONG_LE(7),   // PV present indicator
    SPLIT_LONG_LE(8),   // Time resolution
    SPLIT_LONG_LE(9),   // Source of time synchronization
    
    /* CSIP Nameplate MPPT Ratings: id=0x13, len=8, alloc=8 */
    SPLIT_LONG_LE(1),   // ...
    SPLIT_LONG_LE(2),   // ...

    /* CSIP Configuration: id=0x13, len=164, alloc=164 */
    SPLIT_LONG_LE(1),   // WMax
    SPLIT_LONG_LE(2),   // WChaMax
    SPLIT_LONG_LE(3),   // VAMax
    SPLIT_LONG_LE(4),   // VAChaMax
    SPLIT_LONG_LE(5),   // VArMax
    SPLIT_LONG_LE(6),   // CtlHzHiLim
    SPLIT_LONG_LE(7),   // CtlHzLoLim
    SPLIT_LONG_LE(8),   // VRef
    SPLIT_LONG_LE(9),   // VRefOfs
    SPLIT_LONG_LE(10),   // WGra
    SPLIT_LONG_LE(11),   // WChaGra
    SPLIT_LONG_LE(12),   // PFsign (optional)
    SPLIT_LONG_LE(13),   // PFExt
    SPLIT_LONG_LE(14),   // VArAct
    SPLIT_LONG_LE(15),   // ClcTotVA (optional)
    SPLIT_LONG_LE(16),   // WMaxLimPct
    SPLIT_LONG_LE(17),   // VArRef
    SPLIT_LONG_LE(18),   // VArWMaxPct
    SPLIT_LONG_LE(19),   // VArMaxPct
    SPLIT_LONG_LE(20),   // VArAvalPct
    SPLIT_LONG_LE(21),   // MinRsvPct
    SPLIT_LONG_LE(22),   // WinTms
    SPLIT_LONG_LE(23),   // RvrtTms
    SPLIT_LONG_LE(24),   // OpMod Bitmask
    SPLIT_LONG_LE(25),   // Volt ride-through arrays
    SPLIT_LONG_LE(26),   // Freq ride-through arrays
    SPLIT_LONG_LE(27),   // Dynamic volt/var arrays
    SPLIT_LONG_LE(28),   // RampTms
    SPLIT_LONG_LE(29),   // RampRte
    SPLIT_LONG_LE(30),   // NomUpRamp
    SPLIT_LONG_LE(31),   // NomDnRamp
    SPLIT_LONG_LE(32),   // EmgRampUpRtg
    SPLIT_LONG_LE(33),   // ConnRampDnRtg
    SPLIT_LONG_LE(34),   // ConnRampUpRtg
    SPLIT_LONG_LE(35),   // RampRtePct
    SPLIT_LONG_LE(36),   // ConnDly
    SPLIT_LONG_LE(37),
    SPLIT_LONG_LE(38),
    SPLIT_LONG_LE(39),
    SPLIT_LONG_LE(40),
    SPLIT_LONG_LE(41),

    /* CSIP Set Array: id=0x14, len=36, alloc=36 */
    SPLIT_LONG_LE(0),   // PairArray x0
    SPLIT_LONG_LE(0),   // PairArray y0
    SPLIT_LONG_LE(1),   // PairArray x1
    SPLIT_LONG_LE(1),   // PairArray y1
    SPLIT_LONG_LE(2),   // PairArray x2
    SPLIT_LONG_LE(2),   // PairArray y2
    SPLIT_LONG_LE(3),   // PairArray x3
    SPLIT_LONG_LE(3),   // PairArray y3
    SPLIT_LONG_LE(4),   // PairArray x4
    SPLIT_LONG_LE(4),   // PairArray y4
    SPLIT_LONG_LE(5),   // PairArray x5
    SPLIT_LONG_LE(5),   // PairArray y5
    SPLIT_LONG_LE(48),   // IndpUnits
    SPLIT_LONG_LE(52),   // DeptRef
    SPLIT_LONG_LE(56),   // RmpPT1Tms
    SPLIT_LONG_LE(60),   // RmpDecTmm
    SPLIT_LONG_LE(64),   // RmpIncTmm
    SPLIT_LONG_LE(68),   // RmpRsUp
    SPLIT_LONG_LE(72),   // DeptRefStr
    SPLIT_LONG_LE(76),   // DeptRefStop
    
    /* CSIP Issue Command: id=0x15, len=24, alloc=24 */
    SPLIT_LONG_LE(1),   // InCurve
    SPLIT_LONG_LE(2),   // ModEna
    SPLIT_LONG_LE(3),   // ModType
    SPLIT_LONG_LE(4),   // WinTm
    SPLIT_LONG_LE(5),   // RvrtTms
    SPLIT_LONG_LE(6),   // RmpTms

    /* CSIP Operations: id=0x16, len=16, alloc=16 */
    SPLIT_LONG_LE(1),   // Time value in Seconds
    SPLIT_LONG_LE(2),   // Time value in Seconds
    SPLIT_LONG_LE(3),   // Time value in Seconds
    SPLIT_LONG_LE(4),   // Bit value
    
    /* CSIP Issue Control: id=0x17, len=4, alloc=4 */
    SPLIT_LONG_LE(1),   // I/O Register

    /* Application Extension: id=0xFF, len=0, alloc=256 */
    _ERS16, _ERS16, _ERS16, _ERS16,
    _ERS16, _ERS16, _ERS16, _ERS16,
    _ERS16, _ERS16, _ERS16, _ERS16,
    _ERS16, _ERS16, _ERS16, _ERS16,
    _ERS16, _ERS16, _ERS16, _ERS16,
    _ERS16, _ERS16, _ERS16, _ERS16,
    _ERS16, _ERS16, _ERS16, _ERS16,
    _ERS16, _ERS16, _ERS16, _ERS16,
    _ERS16, _ERS16, _ERS16, _ERS16,
    _ERS16, _ERS16, _ERS16, _ERS16,
    _ERS16, _ERS16, _ERS16, _ERS16,
    _ERS16, _ERS16, _ERS16, _ERS16,
    _ERS16, _ERS16, _ERS16, _ERS16,
    _ERS16, _ERS16, _ERS16, _ERS16,
    _ERS16, _ERS16, _ERS16, _ERS16,
    _ERS16, _ERS16, _ERS16, _ERS16,
    _ERS16, _ERS16, _ERS16, _ERS16,
    _ERS16, _ERS16, _ERS16, _ERS16,
    _ERS16, _ERS16, _ERS16, _ERS16,
    _ERS16, _ERS16, _ERS16, _ERS16,
    _ERS16, _ERS16, _ERS16, _ERS16,
    _ERS16, _ERS16, _ERS16, _ERS16,
    _ERS16, _ERS16, _ERS16, _ERS16,
    _ERS16, _ERS16, _ERS16, _ERS16,
    _ERS16, _ERS16, _ERS16, _ERS16,
    _ERS16, _ERS16, _ERS16, _ERS16,
    _ERS16, _ERS16, _ERS16, _ERS16,
    _ERS16, _ERS16, _ERS16, _ERS16,
    _ERS16, _ERS16, _ERS16, _ERS16,
    _ERS16, _ERS16, _ERS16, _ERS16,
    _ERS16, _ERS16, _ERS16, _ERS16,
    _ERS16, _ERS16, _ERS16, _ERS16,
};



#endif

